/**
 * @fileOverview Security group creation step of the ECS provisioning wizard.
 * @name security
 * @author Derrick Oswald
 * @version 1.0
 */
define
(
    [],
    /**
     * @summary Get/create security groups for master and slave.
     * @description Gets the security groups the user has and choose or create one each for master and slave instances.
     * @name security
     * @exports security
     * @version 1.0
     */
    function ()
    {
        var groups = null;

        function show_groups (data)
        {
            function wrap (group)
            {
                return ("<option value=\"" + group.GroupName + "\">" + group.GroupName + " (" + group.GroupId + " " + group.Description +")" + "</option>")
            }
            groups = data.SecurityGroups;
            var options = groups.map (wrap).join ("\n");
            document.getElementById ("master_security_group_list").innerHTML = options;
            document.getElementById ("worker_security_group_list").innerHTML = options;
            change_group (null)
        }

        function lookup_group (name)
        {
            var found = null;
            function find (group)
            {
                if (group.GroupName == name)
                    found = group;
            }
            if (null != groups)
                groups.forEach (find);
            return (found);
        }

        function change_group (event)
        {
            var master_group_name = document.getElementById ("master_security_group").value;
            var worker_group_name = document.getElementById ("worker_security_group").value;
            var master_group = lookup_group (master_group_name)
            var worker_group = lookup_group (worker_group_name)
            var needed = ((null == master_group) || (null == worker_group));
            var valid_names = (("" != master_group_name) && ("" != worker_group_name));
            var creatable = (needed && valid_names)
            document.getElementById ("create_security_groups").disabled = !creatable;
        }

        function add_master_rules (data)
        {
            var id = data.GroupId;
        }

        //  egress
        var s = {
            "DryRun": true, 
            "GroupId": "", 
            "SourceSecurityGroupName": "", 
            "SourceSecurityGroupOwnerId": "", 
            "IpProtocol": "", 
            "FromPort": 0, 
            "ToPort": 0, 
            "CidrIp": "", 
            "IpPermissions": [
                {
                    "IpProtocol": "", 
                    "FromPort": 0, 
                    "ToPort": 0, 
                    "UserIdGroupPairs": [
                        {
                            "UserId": "", 
                            "GroupName": "", 
                            "GroupId": "", 
                            "VpcId": "", 
                            "VpcPeeringConnectionId": "", 
                            "PeeringStatus": ""
                        }
                    ], 
                    "IpRanges": [
                        {
                            "CidrIp": ""
                        }
                    ], 
                    "Ipv6Ranges": [
                        {
                            "CidrIpv6": ""
                        }
                    ], 
                    "PrefixListIds": [
                        {
                            "PrefixListId": ""
                        }
                    ]
                }
            ]
        }

        // ingress
        var dd = {
            "DryRun": true, 
            "GroupName": "", 
            "GroupId": "", 
            "SourceSecurityGroupName": "", 
            "SourceSecurityGroupOwnerId": "", 
            "IpProtocol": "", 
            "FromPort": 0, 
            "ToPort": 0, 
            "CidrIp": "", 
            "IpPermissions": [
                {
                    "IpProtocol": "", 
                    "FromPort": 0, 
                    "ToPort": 0, 
                    "UserIdGroupPairs": [
                        {
                            "UserId": "", 
                            "GroupName": "", 
                            "GroupId": "", 
                            "VpcId": "", 
                            "VpcPeeringConnectionId": "", 
                            "PeeringStatus": ""
                        }
                    ], 
                    "IpRanges": [
                        {
                            "CidrIp": ""
                        }
                    ], 
                    "Ipv6Ranges": [
                        {
                            "CidrIpv6": ""
                        }
                    ], 
                    "PrefixListIds": [
                        {
                            "PrefixListId": ""
                        }
                    ]
                }
            ]
        }

//        print("Setting up security groups...")
//        master_group = get_or_make_group(conn, cluster_name + "-master", opts.vpc_id)
//        slave_group = get_or_make_group(conn, cluster_name + "-slaves", opts.vpc_id)
//        authorized_address = opts.authorized_address // "--authorized-address", type="string", default="0.0.0.0/0",
//        if master_group.rules == []:  # Group was just now created
//            if opts.vpc_id is None:
//                master_group.authorize(src_group=master_group)
//                master_group.authorize(src_group=slave_group)
//            else:
//                master_group.authorize(ip_protocol='icmp', from_port=-1, to_port=-1,
//                                       src_group=master_group)
//                master_group.authorize(ip_protocol='tcp', from_port=0, to_port=65535,
//                                       src_group=master_group)
//                master_group.authorize(ip_protocol='udp', from_port=0, to_port=65535,
//                                       src_group=master_group)
//                master_group.authorize(ip_protocol='icmp', from_port=-1, to_port=-1,
//                                       src_group=slave_group)
//                master_group.authorize(ip_protocol='tcp', from_port=0, to_port=65535,
//                                       src_group=slave_group)
//                master_group.authorize(ip_protocol='udp', from_port=0, to_port=65535,
//                                       src_group=slave_group)
//            master_group.authorize('tcp', 22, 22, authorized_address)
//            master_group.authorize('tcp', 8080, 8081, authorized_address)
//            master_group.authorize('tcp', 18080, 18080, authorized_address)
//            master_group.authorize('tcp', 19999, 19999, authorized_address)
//            master_group.authorize('tcp', 50030, 50030, authorized_address)
//            master_group.authorize('tcp', 50070, 50070, authorized_address)
//            master_group.authorize('tcp', 60070, 60070, authorized_address)
//            master_group.authorize('tcp', 4040, 4045, authorized_address)
//            # Rstudio (GUI for R) needs port 8787 for web access
//            master_group.authorize('tcp', 8787, 8787, authorized_address)
//            # HDFS NFS gateway requires 111,2049,4242 for tcp & udp
//            master_group.authorize('tcp', 111, 111, authorized_address)
//            master_group.authorize('udp', 111, 111, authorized_address)
//            master_group.authorize('tcp', 2049, 2049, authorized_address)
//            master_group.authorize('udp', 2049, 2049, authorized_address)
//            master_group.authorize('tcp', 4242, 4242, authorized_address)
//            master_group.authorize('udp', 4242, 4242, authorized_address)
//            # RM in YARN mode uses 8088
//            master_group.authorize('tcp', 8088, 8088, authorized_address)


        function add_rules (master_group, worker_group)
        {
        }

        function create_security_groups (event)
        {
            var master_group_name = document.getElementById ("master_security_group").value;
            var worker_group_name = document.getElementById ("worker_security_group").value;
            var master_group = lookup_group (master_group_name)
            var worker_group = lookup_group (worker_group_name)
            var needed = [];
            if (null == master_group)
                needed.push (master_group_name);
            if (null == worker_group)
                needed.push (worker_group_name);
            var count = needed.length;
            var ec2 = new AWS.EC2 ();
            if (count != 0)
            {
                function gather (data, group)
                {
                    count++;
                    group.GroupId = data.GroupId;
                    if (count >= needed.length)
                        add_rules (master_group, worker_group);
                }
                if (null == master_group)
                {
                    var params =
                    {
                        GroupName: master_group_name, 
                        Description: "Security group for master instances", 
                    };
                    master_group =
                    {
                        GroupName: params.GroupName, 
                        Description: params.Description, 
                        IpPermissionsEgress: [],
                        IpPermissions: []
                    }
                    ec2.createSecurityGroup (params, function (err, data) {
                        if (err) console.log (err, err.stack); // an error occurred
                        else     gather (data, master_group);
                    });
                }
                if (null == worker_group)
                {
                    var params =
                    {
                        GroupName: worker_group_name, 
                        Description: "Security group for worker instances", 
                    };
                    worker_group =
                    {
                        GroupName: params.GroupName, 
                        Description: params.Description, 
                        IpPermissionsEgress: [],
                        IpPermissions: []
                    }
                    ec2.createSecurityGroup (params, function (err, data) {
                        if (err) console.log (err, err.stack); // an error occurred
                        else     gather (data, worker_group);
                    });
                }
            }

        }

        /**
         * Form initialization function.
         *
         * @param {object} event - the tab being shown event, <em>not used</em>
         * @function init
         * @memberOf module:security
         */
        function init (event)
        {
            if ((null == groups) || (null == event))
            {
                var ec2 = new AWS.EC2 ();
                ec2.describeSecurityGroups ({}, function (err, data) {
                    if (err) console.log (err, err.stack); // an error occurred
                    else     show_groups (data);     // successful response
                });
            }
        }

        function term (event)
        {
            this.master_security_group = lookup_group (document.getElementById ("master_security_group").value);
            this.worker_security_group = lookup_group (document.getElementById ("worker_security_group").value);
        }

        return (
            {
                getStep: function ()
                {
                    return (
                        {
                            id: "security",
                            title: "Security Groups",
                            template: "templates/security.mst",
                            hooks:
                            [
                                { id: "master_security_group", event: "change", code: change_group },
                                { id: "master_security_group", event: "input", code: change_group },
                                { id: "worker_security_group", event: "change", code: change_group },
                                { id: "worker_security_group", event: "input", code: change_group },
//                                { id : "create_cluster", event : "click", code : create_cluster }
                            ],
                            transitions:
                            {
                                enter: init,
                                leave: term
                            }
                        }
                    );
                }
            }
        );
    }
);