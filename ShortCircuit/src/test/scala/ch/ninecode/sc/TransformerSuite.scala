package ch.ninecode.sc

import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.HashMap
import java.util.Map
import java.util.TimeZone

import org.apache.spark.sql.SparkSession
import org.apache.spark.storage.StorageLevel

import ch.ninecode.cim.CIMNetworkTopologyProcessor
import ch.ninecode.gl.GridLABD
import ch.ninecode.gl.TransformerSet
import ch.ninecode.gl.Transformers

class TransformerSuite
    extends
        SparkSuite
{
    val PRIVATE_FILE_DEPOT = "private_data/"

    test ("transformer area")
    {
        session: SparkSession ⇒
            val filename = PRIVATE_FILE_DEPOT + "bkw_cim_export_schopfen_all" + ".rdf"

            val start = System.nanoTime
            val files = filename.split (",")
            val options = new HashMap[String, String] ().asInstanceOf[Map[String,String]]
            options.put ("path", filename)
            options.put ("StorageLevel", "MEMORY_AND_DISK_SER")
            options.put ("ch.ninecode.cim.make_edges", "false")
            options.put ("ch.ninecode.cim.do_join", "false")
            options.put ("ch.ninecode.cim.do_topo", "false") // use the topological processor after reading
            options.put ("ch.ninecode.cim.do_topo_islands", "false")

            val elements = session.sqlContext.read.format ("ch.ninecode.cim").options (options).load (files:_*)
            elements.persist (StorageLevel.MEMORY_AND_DISK_SER)
            println (elements.count + " elements")
            val read = System.nanoTime
            println ("read: " + (read - start) /  1e9 + " seconds")

            // identify topological nodes and islands
            val ntp = new CIMNetworkTopologyProcessor (session, StorageLevel.fromString ("MEMORY_AND_DISK_SER"), true, true, true)
            val ele = ntp.process (true).persist (StorageLevel.MEMORY_AND_DISK_SER)
            println (ele.count () + " elements")

            val topo = System.nanoTime ()
            println ("topology: " + (topo - read) / 1e9 + " seconds")

            // transformer area calculations
            val debug = false
            val tsa = if (debug)
            {
                org.apache.log4j.LogManager.getLogger ("ch.ninecode.sc.TransformerServiceArea").setLevel (org.apache.log4j.Level.DEBUG)
                TransformerServiceArea (session, true)
            }
            else
                TransformerServiceArea (session)
            val trafos_islands = tsa.getTransformerServiceAreas.map (x ⇒ (x._2, x._1)) // (trafosetid, islandid)

            val _transformers = new Transformers (session, StorageLevel.MEMORY_AND_DISK_SER)
            val tdata = _transformers.getTransformerData (true)

            // get all low voltage power transformers
            // ToDo: fix this 1kV multiplier on the voltages
            val niederspannug = tdata.filter (td ⇒ td.voltage0 != 0.4 && td.voltage1 == 0.4)
            val transformers = niederspannug.groupBy (_.terminal1.TopologicalNode).values.map (_.toArray).map (TransformerSet (_))

            val scopt = ShortCircuitOptions ()
            val short_circuit = ShortCircuit (session, StorageLevel.MEMORY_AND_DISK_SER, scopt)
            val areas = short_circuit.queryNetwork (trafos_islands)
            val now = Calendar.getInstance
            val dir = "./results"
            val simulations = areas.join (transformers.keyBy (_.transformer_name)).map (x ⇒ (x._1, x._2._2, x._2._1._1, x._2._1._2)) // (areaid, trafoset, [nodes], [edges])
                .map (x ⇒
                    SimulationTransformerServiceArea (
                        simulation = x._1,
                        island = x._1,
                        transformer = x._2,
                        nodes = x._3,
                        edges = x._4,
                        start_time = now,
                        finish_time = now,
                        directory = dir))
            val sc = System.nanoTime ()
            println ("transformer service areas: " + (sc - topo) / 1e9 + " seconds")

            def generate (gridlabd: GridLABD, trafokreis: SimulationTransformerServiceArea): Unit =
            {
                val start = System.nanoTime()
                // for dates without time zones, the timezone of the machine is used:
                //    date +%Z
                // timezone can be set on each node of the cluster with:
                //    dpkg-reconfigure tzdata
                // then choose Europe and then choose Zürich
                //
                // all dates generated by this program include the time zone
                val USE_UTC = true
                val _DateFormat = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss z")
                if (USE_UTC)
                    _DateFormat.setTimeZone (TimeZone.getTimeZone ("UTC"))
                else
                    _DateFormat.setTimeZone (TimeZone.getTimeZone ("CET"))
                val generator = ScGLMGenerator (one_phase = true, date_format = _DateFormat, trafokreis)
                gridlabd.export (generator)
            }
            val gridlabd = new GridLABD (session, topological_nodes = true, one_phase = true, storage_level = StorageLevel.MEMORY_AND_DISK_SER, workdir = PRIVATE_FILE_DEPOT)
            simulations.foreach (
                x ⇒
                {
                    generate (gridlabd, x)
                }
            )

            val sim = System.nanoTime ()
            println ("total: " + (sim - start) / 1e9 + " seconds")
    }
}
