package ch.ninecode.sc

import java.nio.charset.StandardCharsets
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.HashMap
import java.util.Map
import java.util.TimeZone

import org.apache.spark.sql.SparkSession
import org.apache.spark.storage.StorageLevel
import ch.ninecode.cim.CIMNetworkTopologyProcessor
import ch.ninecode.gl.Complex
import ch.ninecode.gl.GridLABD
import ch.ninecode.gl.TransformerSet
import ch.ninecode.gl.Transformers
import org.apache.spark.rdd.RDD

class TransformerSuite
    extends
        SparkSuite
{
    val PRIVATE_FILE_DEPOT = "private_data/"

    test ("transformer area")
    {
        session: SparkSession ⇒
            val filename = PRIVATE_FILE_DEPOT + "bkw_cim_export_schopfen_all" + ".rdf"

            val start = System.nanoTime
            val files = filename.split (",")
            val options = new HashMap[String, String] ().asInstanceOf[Map[String,String]]
            options.put ("path", filename)
            options.put ("StorageLevel", "MEMORY_AND_DISK_SER")
            options.put ("ch.ninecode.cim.make_edges", "false")
            options.put ("ch.ninecode.cim.do_join", "false")
            options.put ("ch.ninecode.cim.do_topo", "false") // use the topological processor after reading
            options.put ("ch.ninecode.cim.do_topo_islands", "false")

            val elements = session.sqlContext.read.format ("ch.ninecode.cim").options (options).load (files:_*)
            elements.persist (StorageLevel.MEMORY_AND_DISK_SER)
            println (elements.count + " elements")
            val read = System.nanoTime
            println ("read: " + (read - start) /  1e9 + " seconds")

            // identify topological nodes and islands
            val ntp = new CIMNetworkTopologyProcessor (session, StorageLevel.fromString ("MEMORY_AND_DISK_SER"), true, true, true)
            val ele = ntp.process (true).persist (StorageLevel.MEMORY_AND_DISK_SER)
            println (ele.count () + " elements")

            val topo = System.nanoTime ()
            println ("topology: " + (topo - read) / 1e9 + " seconds")

            // transformer area calculations
            val debug = false
            val tsa = if (debug)
            {
                org.apache.log4j.LogManager.getLogger ("ch.ninecode.sc.TransformerServiceArea").setLevel (org.apache.log4j.Level.DEBUG)
                TransformerServiceArea (session, true)
            }
            else
                TransformerServiceArea (session)
            val trafos_islands = tsa.getTransformerServiceAreas.map (x ⇒ (x._2, x._1)) // (trafosetid, islandid)

            val _transformers = new Transformers (session, StorageLevel.MEMORY_AND_DISK_SER)
            val tdata = _transformers.getTransformerData (true)

            // get all low voltage power transformers
            // ToDo: fix this 1kV multiplier on the voltages
            val niederspannug = tdata.filter (td ⇒ td.voltage0 != 0.4 && td.voltage1 == 0.4)
            val transformers = niederspannug.groupBy (_.terminal1.TopologicalNode).values.map (_.toArray).map (TransformerSet (_))

            val scopt = ShortCircuitOptions ()
            val short_circuit = ShortCircuit (session, StorageLevel.MEMORY_AND_DISK_SER, scopt)
            val areas = short_circuit.queryNetwork (trafos_islands)
            val now = Calendar.getInstance
            val simulations = areas.join (transformers.keyBy (_.transformer_name)).map (x ⇒ (x._1, x._2._2, x._2._1._1, x._2._1._2)) // (areaid, trafoset, [nodes], [edges])
                .map (x ⇒
                {
                    SimulationTransformerServiceArea (
                        simulation = x._1,
                        island = x._1,
                        transformer = x._2,
                        nodes = x._3,
                        edges = x._4,
                        start_time = now,
                        directory = x._2.transformer_name)
                }
                )
            val sc = System.nanoTime ()
            println ("transformer service areas: " + (sc - topo) / 1e9 + " seconds")

            // for dates without time zones, the timezone of the machine is used:
            //    date +%Z
            // timezone can be set on each node of the cluster with:
            //    dpkg-reconfigure tzdata
            // then choose Europe and then choose Zürich
            //
            // all dates generated by this program include the time zone
            val USE_UTC = true
            val _DateFormat = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss z")
            if (USE_UTC)
                _DateFormat.setTimeZone (TimeZone.getTimeZone ("UTC"))
            else
                _DateFormat.setTimeZone (TimeZone.getTimeZone ("CET"))

            def generate (gridlabd: GridLABD, trafokreis: SimulationTransformerServiceArea): Unit =
            {
                val start = System.nanoTime()
                val generator = ScGLMGenerator (one_phase = true, date_format = _DateFormat, trafokreis)
                gridlabd.export (generator)
            }
            val gridlabd = new GridLABD (session, topological_nodes = true, one_phase = true, storage_level = StorageLevel.MEMORY_AND_DISK_SER, workdir = PRIVATE_FILE_DEPOT)
            val experiments = simulations.flatMap (
                x ⇒
                {
                    generate (gridlabd, x)
                    x.experiments
                }
            )
            def short (exp: ScExperiment): Array[Byte] =
            {
                val ret = new StringBuilder ()
                val gigaohm = Complex (1e9, 0)
                def addrow (time: Calendar, impedance: Complex): Unit =
                {
                    ret.append (_DateFormat.format (time.getTime))
                    ret.append (",")
                    ret.append (impedance.re)
                    ret.append (",")
                    ret.append (impedance.im)
                    ret.append ("\n")
                }
                addrow (exp.t0, gigaohm) // gridlab extends the first and last rows till infinity -> make them zero
                addrow (exp.t1, exp.impedance)
                addrow (exp.t2, gigaohm) // gridlab extends the first and last rows till infinity -> make them zero

                ret.toString.getBytes (StandardCharsets.UTF_8)
            }
            def generate_player_file (gridlabd: GridLABD) (experiment: ScExperiment): Unit =
            {
                if (false)
                {
                    gridlabd.writeInputFile (experiment.trafo, "input_data/" + experiment.house + "_R.csv", short (experiment))
                    gridlabd.writeInputFile (experiment.trafo, "input_data/" + experiment.house + "_S.csv", short (experiment))
                    gridlabd.writeInputFile (experiment.trafo, "input_data/" + experiment.house + "_T.csv", short (experiment))
                }
                else
                    gridlabd.writeInputFile (experiment.trafo, "input_data/" + experiment.house + ".csv", short (experiment))
            }
            experiments.foreach (generate_player_file (gridlabd))

            val sim = System.nanoTime ()
            println ("total: " + (sim - start) / 1e9 + " seconds")
    }
}
