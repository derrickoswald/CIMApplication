package ch.ninecode.lv

import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.TimeZone

import scala.io.Source

import org.apache.spark.rdd.RDD
import org.apache.spark.sql.SparkSession
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.apache.log4j.Level
import org.apache.log4j.LogManager

import ch.ninecode.cim.CIMClasses
import ch.ninecode.cim.CIMRDD
import ch.ninecode.cim.DefaultSource
import ch.ninecode.gl.GLMEdge
import ch.ninecode.gl.GridLABD
import ch.ninecode.model.TopologicalNode
import ch.ninecode.net.Island.Edges
import ch.ninecode.net.Island.Nodes
import ch.ninecode.net.Island.identifier
import ch.ninecode.net.Island.island_id
import ch.ninecode.net.Net
import ch.ninecode.net.TransformerData
import ch.ninecode.net.TransformerIsland
import ch.ninecode.net.TransformerServiceArea
import ch.ninecode.net.TransformerSet
import ch.ninecode.net.Transformers
import ch.ninecode.util.CIMInitializer
import ch.ninecode.util.Main
import ch.ninecode.util.MainOptions
import ch.ninecode.util.SparkOptions
import ch.ninecode.util.Util

/**
 * Generate GridLAB-D model (.glm) files for all, or selected, transformer service areas in a CIM file.
 *
 * @param session the Spark session to use
 * @param options the options for Spark, CIM, and this program
 */
case class LowVoltage (session: SparkSession, options: LowVoltageOptions) extends CIMRDD
{
    if (options.verbose)
    {
        org.apache.log4j.LogManager.getLogger("ch.ninecode.lv.LowVoltage").setLevel(org.apache.log4j.Level.INFO)
        org.apache.log4j.LogManager.getLogger("ch.ninecode.mfi.PowerFeeding$").setLevel(org.apache.log4j.Level.INFO)
    }
    implicit val spark: SparkSession = session
    implicit val log: Logger = LoggerFactory.getLogger(getClass)

    // for dates without time zones, the timezone of the machine is used:
    //    date +%Z
    // timezone can be set on each node of the cluster with:
    //    dpkg-reconfigure tzdata
    // then choose Europe and then choose ZÃ¼rich
    //
    // all dates generated by this program include the time zone
    val USE_UTC = true
    val _DateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z")
    if (USE_UTC)
        _DateFormat.setTimeZone(TimeZone.getTimeZone("UTC"))
    else
        _DateFormat.setTimeZone(TimeZone.getTimeZone("CET"))

    def generate (gridlabd: GridLABD, trafokreise: RDD[LowVoltageTrafokreis]): Int =
    {
        log.info(s"exporting: ${trafokreise.count} transformer service areas")
        LowVoltage.time("export: %s seconds")
        {
            def doit (trafokreis: LowVoltageTrafokreis): Int =
            {
                val generator = new LowVoltageGLMGenerator(!options.three, _DateFormat, trafokreis)
                gridlabd.export(generator)
                1
            }

            val files = trafokreise.map(doit).cache
            val fc = files.fold(0)(_ + _)
            log.info(s"exported: $fc transformer service areas")
            fc
        }
    }

    // determine transformer list if any
    def getTrafos: Array[String] =
    {
        if ("" != options.trafos)
        {
            // do all transformers listed in the file
            val source = Source.fromFile(options.trafos, "UTF-8")
            val lines = source.getLines().filter(_ != "").toArray
            if (0 == lines.length)
            {
                log.error("no transformers to process")
                sys.exit(1)
            }
            source.close
            lines
        }
        else
            Array()
    }

    def getTransformers: Map[String, TransformerSet] =
    {
        val transformer_data = Transformers(session, options.cim_options.storage).getTransformers()
        val tx = transformer_data.keyBy(_.node1.id) // (low_voltage_node_name, TransformerData)
            .join(get[TopologicalNode].keyBy(_.id)) // (low_voltage_node_name, (TransformerData, TopologicalNode))
            .map(x => (x._1, (x._2._1, x._2._2.TopologicalIsland))) // (low_voltage_node_name, (TransformerData, island))
            .groupByKey.values

        def toTransformerSet (transformers: Iterable[(TransformerData, String)]): (String, TransformerSet) =
        {
            val islands = transformers.map(_._2).toSet
            if (islands.size > 1)
                log.error(s"not all transformers are members of the same island (${islands.mkString(",")})")
            val set = TransformerSet(transformers.map(_._1).toArray)
            (set.transformer_name, set)
        }

        tx.map(toTransformerSet).collect.toMap
    }

    def plural (number: Int): String = if (1 == number) "" else "s"

    def run (): Long =
    {
        // determine transformer list if any
        val trafos = getTrafos

        // transformer area calculations
        val tsa = TransformerServiceArea(session, options.cim_options.storage)
        // only proceed if topological processing was done (there are TopologicalIslands)
        if (tsa.hasIslands)
        {
            val islands_trafos: RDD[(island_id, identifier)] = tsa.getTransformerServiceAreas
            val numareas = islands_trafos.map(_._2).distinct.count.toInt
            log.info(s"""$numareas transformer service area${plural(numareas)} found""")

            // maybe reduce the set of islands
            val islands_to_do: RDD[(island_id, identifier)] =
                if (0 != trafos.length)
                    islands_trafos.filter(pair => trafos.contains(pair._2))
                else
                    islands_trafos

            val island_helper = new LowVoltageIsland(session, options.cim_options.storage)
            // Lines.DEFAULT_CABLE_RESISTANCE_LIMIT = options.cable_impedance_limit
            val graph_stuff: (Nodes, Edges) = island_helper.queryNetwork(islands_to_do.map(_.swap))
            @SuppressWarnings(Array("org.wartremover.warts.AsInstanceOf"))
            val nodes = graph_stuff._1.groupByKey.asInstanceOf[RDD[(identifier, Iterable[LowVoltageNode])]]
            @SuppressWarnings(Array("org.wartremover.warts.AsInstanceOf"))
            val edges = graph_stuff._2.groupByKey.asInstanceOf[RDD[(identifier, Iterable[GLMEdge])]]
            val areas = nodes.join(edges)

            val transformers: Map[String, TransformerSet] = getTransformers
            val start = Calendar.getInstance()
            val trafokreise: RDD[LowVoltageTrafokreis] = areas.flatMap(
                area =>
                {
                    val (id, (nodes, edges)) = area
                    transformers.find(_._1 == id) match
                    {
                        case Some(set) =>
                            val island = new TransformerIsland(Array(set._2))
                            Some(LowVoltageTrafokreis(start, island, nodes, edges))
                        case _ =>
                            None
                    }
                }
            )
            val gridlabd = new GridLABD(session, options.cim_options.storage, options.getWorkDir)
            generate(gridlabd, trafokreise)
        }
        else
            0L
    }
}

object LowVoltage extends CIMInitializer[LowVoltageOptions] with Main
{
    def run (options: LowVoltageOptions): Unit =
    {
        if (options.verbose)
            LogManager.getLogger(getClass).setLevel(Level.INFO)
        if (options.main_options.valid)
        {
            if (options.cim_options.files.nonEmpty)
            {
                val session: SparkSession = createSession(options)
                readCIM(session, options)
                time("execution: %s seconds")
                {
                    val lv = LowVoltage(session, options)
                    val _ = lv.run()
                }
            }
            else
                log.error("no CIM files specified")
        }
    }

    def main (args: Array[String])
    {
        val have = util.Properties.versionNumberString
        val need = scala_library_version
        if (have != need)
        {
            log.error(s"Scala version ($have) does not match the version ($need) used to build $application_name")
            sys.exit(1)
        }
        else
        {
            // get the necessary jar files to send to the cluster
            val jars = Set(
                jarForObject(new DefaultSource()),
                jarForObject(LowVoltageOptions())
            ).toArray

            // compose the classes to be registered with Kryo
            val kryo = Array.concat(
                // register CIMReader classes
                CIMClasses.list,
                // register Net classes
                Net.classes,
                // register GridLAB-D classes
                GridLABD.classes,
                // register Util classes
                Util.classes)

            // initialize the default options
            val temp = LowVoltageOptions()
            val default = LowVoltageOptions(
                main_options = MainOptions(application_name, application_version),
                spark_options = SparkOptions(jars = jars, kryo = kryo),
                cim_options = temp.cim_options.copy(options = temp.cim_options.toMap)
            )

            // parse the command line arguments
            new LowVoltageOptionsParser(default).parse(args, default) match
            {
                case Some(options) =>
                    // execute the main program if everything checks out
                    run(options)
                    if (!options.main_options.unittest)
                        sys.exit(0)
                case None =>
                    sys.exit(1)
            }
        }
    }
}
